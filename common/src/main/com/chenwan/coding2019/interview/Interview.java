package main.com.chenwan.coding2019.interview;

/**
 * @program: base
 * @description:
 * @author: cliffcw
 * @create: 2019-07-21 12:02
 */
public class Interview {

    /** * @Description:
     * @Param:
     * @return:
     * @Author: cliffcw
     * @Date:
     *
     * 1 二维数组查找，可以从一个角开始对比，对比一次去掉一行或者一列
     *
     * 2 数组复制：数据从头到尾的复制可能复制多遍，可以考虑从尾部开始复制和对比
     *
     * 3 链表 从尾到头打印一个链表，可以用一个栈来实现，后进先出。也可以用递归来实现，不过递归要考虑栈长度，怕栈溢出，可以用尾递归。
     *
     * 4 树 前序遍历，中序遍历，后序遍历。每种遍历有两种实现方式：递归和循环。  递归更简洁。
     *     宽度优先遍历：从根开始从上到下，从左到右遍历。
     *     二叉树：二叉，
     *     二叉搜索树：左<根<右
     *     堆
     *     红黑树
     *
     *  5 栈和队列 栈：相当于一个桶，队列：相当于一根水管。 top 返回栈顶部元素，pop，删出栈顶部元素。
     *
     *  算法：
     *
     *  重点：二分查找，归并排序，快速排序
     *
     *  二维数组搜索路径 回溯法：适合用递归实现 或 用栈来模拟递归（也是递归）
     *
     *  最优解（可分为多个子问题） 动态规划法：子问题的最优解算出来用数组存储下来，再基于子问题计算大问题的解
     *
     *  特殊的问题能得出最优解：贪婪算法
     *
     *  递归和循环 递归：调用函数自身，分配栈， 循环：一个循环体中进行
     *
     *  斐波那契数列 0 1 1 2 3 5 8 ...
     *      青蛙跳台阶，就是斐波那契数列
     *
     *  查找和排序： 快排、二分查找
     *
     *  回溯法 解决二维数组、矩阵的问题
     *
     *  动态规划 贪婪算法 剪绳子 尽可能的剪成3的长度，待证明
     *
     *  二进制 与 或 异或 左移 右移
     *
     */

    /*

    证明贪婪算法 为什么尽可能剪为3
    即要证明：f(n) = max(i*f(n-i) 证明其中i=3

    设g(i) = i*f(n-i) g(i-2) = (i-2)*f(n-(i_2))
    当i>=5时
    i>=5>4
    所以 i>=4
    所以 i-2*i >= 4-2*i
    所以 -i >= 2*(2-i)
    所以 i <= 2*(i-2)
    所以 i*f(n-i) <= (i-2)*2*f(n-i)----1式
    因为 2*f(n-i)=2*f(n-i+2-2)
    又 f(n) = max(i*f(n-i)) 即 i*f(n-i) <= f(n) 取 n=n-i+2 且 i=2 代入上面
    得 2*f(n-i)=2*f(n-i+2-2)<=f(n-i+2) 代入 1式
    得 i*f(n-i) <= (i-2)*f(n-i+2)
    得 i*f(n-i) <= (i-2)*f(n-(i-2))
    则 g(i) = i*f(n-i) <= (i-2)*f(n-(i-2))
    所以 g(i) <= g(i-2)
    即 g(i-2) >= g(i)
    则 g(3)>=g(5)>=g(7)>=g(9)...
    首先如果g(1)是最大的，那就说明f(n)=1×f(n-1)，这样的话对于任意的n, f(n)都相等，显然矛盾。
    其次，g(4) = 2×2×f(n-4) ≤ 2f(n-2) = g(2)
    所以，最终就是要比较g(2)和g(3)谁大

    当n=5时，有3f(2) ≥ 2f(3)，所以g(3) ≥ g(2)成立
    当n=6时，有3f(3) ≥ 2f(4)，所以g(3) ≥ g(2)成立

    假设当n=k时，3f(k-3) ≥ 2f(k-2)成立，从而得到f(k)=3f(k-3)
    n=k+1时，3f(k+1-3) ≥ 2f(k+1-2)成立，即3f(k-2) ≥ 2f(k-1)，从而得到f(k+1)=3f(k+1-3)
    当n=k+3时，
    需要证明3f(k+3-3) ≥ 2(k+3-2)
    就是要证明3f(k) ≥ 2(k+1)
    就是要证明3(3f(k-3)) ≥ 2(3f(k+1-3))
    就是要证明3f(k-3) ≥ 2f(k-2)
    证明完毕
    所以现在就可以得到g(3)≥g(i)的结论了，所以f(n)=3f(n-3)，因为i≥5,所以n肯定也要≥5。
     */
}
